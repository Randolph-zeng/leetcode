# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None




# The point is to figure out the correct bound for min and max at each point! 

class Solution(object):
    def helper(self, root, min_range, max_range):
        if not root:
            return True
        if root.val <= min_range or root.val >= max_range:
            return False

        return (self.helper(root.left, min_range, root.val) and
            self.helper(root.right, root.val, max_range))
        

    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        return self.helper(root, float('-inf'), float('inf'))



# Another interesting solution is to think of the BST order is indeed
# the inorder traversal. We need to make sure the list generated by the 
# inorder traversal is in an increasing mannaer.
'''
    10
5           15
        6       20
its inorder traversal list is 
[5, 10, 6, 15, 20] not monotonically increasing
'''


class Solution(object):
    
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        stack = []
        curr = root
        last_val = float('-inf')
        while curr is not None or len(stack) != 0 :
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            if curr.val <= last_val:
                return False
            last_val = curr.val
            curr = curr.right
        return True




if __name__ == '__main__':
    sol = Solution()
    root = TreeNode(2)
    left = TreeNode(1)
    right = TreeNode(3)
    root.left = left
    root.right = right
    print(sol.isValidBST(root))